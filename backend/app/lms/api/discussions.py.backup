"""
Discussions API - Course discussion forums and threads
"""
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session, joinedload
from typing import List, Optional
from uuid import UUID, uuid4
from datetime import datetime, timezone
from pydantic import BaseModel, Field

from ...core.database import get_db
from ..services.auth_service import get_current_user, require_role
from ..models import (
    LMSUser, Course, Enrollment,
    DiscussionThread, DiscussionReply, DiscussionUpvote
)

router = APIRouter(
    prefix="/api/lms/discussions",
    tags=["Discussions"]
)

# Pydantic models for request/response

class DiscussionThreadCreate(BaseModel):
    course_id: UUID
    lesson_id: Optional[UUID] = None
    title: str = Field(..., min_length=1, max_length=500)
    content: str = Field(..., min_length=1)
    category: Optional[str] = Field(None, pattern="^(general|question|announcement|resource)$")
    is_pinned: bool = False
    is_locked: bool = False

class DiscussionThreadUpdate(BaseModel):
    title: Optional[str] = Field(None, min_length=1, max_length=500)
    content: Optional[str] = Field(None, min_length=1)
    category: Optional[str] = Field(None, pattern="^(general|question|announcement|resource)$")
    is_pinned: Optional[bool] = None
    is_locked: Optional[bool] = None
    is_resolved: Optional[bool] = None

class DiscussionReplyCreate(BaseModel):
    content: str = Field(..., min_length=1)
    parent_reply_id: Optional[UUID] = None
    is_answer: bool = False

class DiscussionReplyUpdate(BaseModel):
    content: Optional[str] = Field(None, min_length=1)
    is_answer: Optional[bool] = None

class DiscussionThreadResponse(BaseModel):
    id: UUID
    course_id: UUID
    lesson_id: Optional[UUID]
    author_id: UUID
    author: dict
    title: str
    content: str
    category: Optional[str]
    is_pinned: bool
    is_locked: bool
    is_resolved: bool
    reply_count: int
    last_activity: datetime
    created_at: datetime
    updated_at: datetime

class DiscussionReplyResponse(BaseModel):
    id: UUID
    thread_id: UUID
    author_id: UUID
    author: dict
    content: str
    parent_reply_id: Optional[UUID]
    is_answer: bool
    upvotes: int
    created_at: datetime
    updated_at: datetime
    replies: List['DiscussionReplyResponse'] = []

# Update forward references
DiscussionReplyResponse.model_rebuild()

def build_author_dict(user: LMSUser) -> dict:
    """Build consistent author info dict for responses"""
    if not user:
        return {"id": "", "first_name": "Unknown", "last_name": "", "email": ""}
    return {
        "id": str(user.id),
        "first_name": user.first_name or "",
        "last_name": user.last_name or "",
        "email": user.email or ""
    }

# Discussion Thread CRUD Operations

@router.post("/threads", response_model=DiscussionThreadResponse, status_code=status.HTTP_201_CREATED)
async def create_discussion_thread(
    thread_data: DiscussionThreadCreate,
    current_user: LMSUser = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Create a discussion thread.
    Simple and quick - students can start discussions easily.
    Instructors can pin/lock threads for announcements.
    """
    course = db.query(Course).filter(Course.id == thread_data.course_id).first()
    if not course:
        raise HTTPException(status_code=404, detail="Course not found")

    user_role = current_user.role.upper() if hasattr(current_user.role, 'upper') else str(current_user.role).upper()
    is_instructor = course.instructor_id == current_user.id or user_role in ["ADMIN", "SUPER_ADMIN"]

    enrollment = db.query(Enrollment).join(Enrollment.cohort).filter(
        Enrollment.user_id == current_user.id,
        Enrollment.cohort.has(course_version_id=course.versions[0].id if course.versions else None)
    ).first() if not is_instructor else None

    if not enrollment and not is_instructor:
        raise HTTPException(status_code=403, detail="Enroll in the course to participate in discussions")

    thread = DiscussionThread(
        course_id=thread_data.course_id,
        lesson_id=thread_data.lesson_id,
        author_id=current_user.id,
        title=thread_data.title,
        content=thread_data.content,
        category=thread_data.category or "general",
        is_pinned=thread_data.is_pinned if is_instructor else False,
        is_locked=thread_data.is_locked if is_instructor else False
    )

    db.add(thread)
    db.commit()
    db.refresh(thread)

    return DiscussionThreadResponse(
        id=thread.id,
        course_id=thread.course_id,
        lesson_id=thread.lesson_id,
        author_id=thread.author_id,
        author=build_author_dict(current_user),
        title=thread.title,
        content=thread.content,
        category=thread.category,
        is_pinned=thread.is_pinned,
        is_locked=thread.is_locked,
        is_resolved=thread.is_resolved,
        reply_count=0,
        last_activity=thread.last_activity_at,
        created_at=thread.created_at,
        updated_at=thread.updated_at
    )

@router.get("/threads", response_model=List[DiscussionThreadResponse])
async def get_discussion_threads(
    course_id: UUID,
    lesson_id: Optional[UUID] = None,
    category: Optional[str] = None,
    current_user: LMSUser = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Get all discussion threads for a course/lesson.
    Optimized with eager loading for fast display.
    Pinned threads always appear first for visibility.
    """
    query = db.query(DiscussionThread).options(
        joinedload(DiscussionThread.author)
    ).filter(DiscussionThread.course_id == course_id)

    if lesson_id:
        query = query.filter(DiscussionThread.lesson_id == lesson_id)
    if category:
        query = query.filter(DiscussionThread.category == category)

    query = query.order_by(
        DiscussionThread.is_pinned.desc(),
        DiscussionThread.last_activity_at.desc()
    )

    threads = query.all()

    return [
        DiscussionThreadResponse(
            id=t.id,
            course_id=t.course_id,
            lesson_id=t.lesson_id,
            author_id=t.author_id,
            author=build_author_dict(t.author),
            title=t.title,
            content=t.content,
            category=t.category,
            is_pinned=t.is_pinned,
            is_locked=t.is_locked,
            is_resolved=t.is_resolved,
            reply_count=t.reply_count,
            last_activity=t.last_activity_at,
            created_at=t.created_at,
            updated_at=t.updated_at
        )
        for t in threads
    ]

@router.get("/threads/{thread_id}", response_model=DiscussionThreadResponse)
async def get_discussion_thread(
    thread_id: UUID,
    current_user: LMSUser = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get single thread details with author info"""
    thread = db.query(DiscussionThread).options(
        joinedload(DiscussionThread.author)
    ).filter(DiscussionThread.id == thread_id).first()

    if not thread:
        raise HTTPException(status_code=404, detail="Thread not found")

    return DiscussionThreadResponse(
        id=thread.id,
        course_id=thread.course_id,
        lesson_id=thread.lesson_id,
        author_id=thread.author_id,
        author=build_author_dict(thread.author),
        title=thread.title,
        content=thread.content,
        category=thread.category,
        is_pinned=thread.is_pinned,
        is_locked=thread.is_locked,
        is_resolved=thread.is_resolved,
        reply_count=thread.reply_count,
        last_activity=thread.last_activity_at,
        created_at=thread.created_at,
        updated_at=thread.updated_at
    )

@router.put("/threads/{thread_id}", response_model=DiscussionThreadResponse)
async def update_discussion_thread(
    thread_id: UUID,
    thread_data: DiscussionThreadUpdate,
    current_user: LMSUser = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Update a discussion thread"""

    thread = discussions_storage["threads"].get(thread_id)
    if not thread:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Thread not found"
        )

    # Check permissions
    course = db.query(Course).filter(Course.id == thread["course_id"]).first()
    is_instructor = course and course.instructor_id == current_user.id
    is_author = thread["author_id"] == current_user.id

    # Author can update content, instructor can update everything
    if not is_author and not is_instructor and current_user.role != "ADMIN":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You don't have permission to update this thread"
        )

    # Update fields
    update_data = thread_data.dict(exclude_unset=True)

    # Only instructor can change pinned/locked status
    if not is_instructor:
        update_data.pop("is_pinned", None)
        update_data.pop("is_locked", None)

    for field, value in update_data.items():
        thread[field] = value

    thread["updated_at"] = datetime.now(timezone.utc)

    # Get author info
    author = db.query(LMSUser).filter(LMSUser.id == thread["author_id"]).first()

    return DiscussionThreadResponse(
        **thread,
        author={
            "id": str(author.id),
            "first_name": author.first_name,
            "last_name": author.last_name,
            "email": author.email
        } if author else {"id": str(thread["author_id"]), "first_name": "Unknown", "last_name": "", "email": ""}
    )

@router.delete("/threads/{thread_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_discussion_thread(
    thread_id: UUID,
    current_user: LMSUser = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Delete a discussion thread"""

    thread = discussions_storage["threads"].get(thread_id)
    if not thread:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Thread not found"
        )

    # Check permissions
    course = db.query(Course).filter(Course.id == thread["course_id"]).first()
    is_instructor = course and course.instructor_id == current_user.id
    is_author = thread["author_id"] == current_user.id

    if not is_author and not is_instructor and current_user.role != "ADMIN":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You don't have permission to delete this thread"
        )

    # Delete thread and its replies
    del discussions_storage["threads"][thread_id]

    # Delete all replies for this thread
    replies_to_delete = [rid for rid, reply in discussions_storage["replies"].items() if reply["thread_id"] == thread_id]
    for reply_id in replies_to_delete:
        del discussions_storage["replies"][reply_id]

# Discussion Reply CRUD Operations

@router.post("/threads/{thread_id}/replies", response_model=DiscussionReplyResponse, status_code=status.HTTP_201_CREATED)
async def create_discussion_reply(
    thread_id: UUID,
    reply_data: DiscussionReplyCreate,
    current_user: LMSUser = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Create a reply to a discussion thread"""

    thread = discussions_storage["threads"].get(thread_id)
    if not thread:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Thread not found"
        )

    if thread["is_locked"]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="This thread is locked"
        )

    # Create reply
    reply_id = uuid4()
    reply = {
        "id": reply_id,
        "thread_id": thread_id,
        "author_id": current_user.id,
        "content": reply_data.content,
        "parent_reply_id": reply_data.parent_reply_id,
        "is_answer": reply_data.is_answer,
        "upvotes": 0,
        "created_at": datetime.now(timezone.utc),
        "updated_at": datetime.now(timezone.utc)
    }

    discussions_storage["replies"][reply_id] = reply

    # Update thread activity
    thread["reply_count"] += 1
    thread["last_activity"] = datetime.now(timezone.utc)

    # Mark thread as resolved if this is marked as answer by instructor
    course = db.query(Course).filter(Course.id == thread["course_id"]).first()
    is_instructor = course and course.instructor_id == current_user.id
    if reply_data.is_answer and is_instructor:
        thread["is_resolved"] = True

    return DiscussionReplyResponse(
        **reply,
        author={
            "id": str(current_user.id),
            "first_name": current_user.first_name,
            "last_name": current_user.last_name,
            "email": current_user.email
        },
        replies=[]
    )

@router.get("/threads/{thread_id}/replies", response_model=List[DiscussionReplyResponse])
async def get_discussion_replies(
    thread_id: UUID,
    current_user: LMSUser = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get all replies for a discussion thread"""

    thread = discussions_storage["threads"].get(thread_id)
    if not thread:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Thread not found"
        )

    # Build reply tree
    replies = []
    reply_map = {}

    # First pass: create all reply objects
    for reply in discussions_storage["replies"].values():
        if reply["thread_id"] != thread_id:
            continue

        # Get author info
        author = db.query(LMSUser).filter(LMSUser.id == reply["author_id"]).first()

        reply_obj = DiscussionReplyResponse(
            **reply,
            author={
                "id": str(author.id),
                "first_name": author.first_name,
                "last_name": author.last_name,
                "email": author.email
            } if author else {"id": str(reply["author_id"]), "first_name": "Unknown", "last_name": "", "email": ""},
            replies=[]
        )
        reply_map[reply["id"]] = reply_obj

    # Second pass: build tree structure
    root_replies = []
    for reply_id, reply_obj in reply_map.items():
        if reply_obj.parent_reply_id and reply_obj.parent_reply_id in reply_map:
            reply_map[reply_obj.parent_reply_id].replies.append(reply_obj)
        else:
            root_replies.append(reply_obj)

    # Sort by upvotes and date
    root_replies.sort(key=lambda x: (x.is_answer, x.upvotes, x.created_at), reverse=True)

    return root_replies

@router.post("/replies/{reply_id}/upvote", response_model=dict)
async def upvote_reply(
    reply_id: UUID,
    current_user: LMSUser = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Upvote a reply"""

    reply = discussions_storage["replies"].get(reply_id)
    if not reply:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Reply not found"
        )

    # Track upvotes (simple implementation)
    upvote_key = f"{current_user.id}:{reply_id}"
    if upvote_key in discussions_storage["upvotes"]:
        # Remove upvote
        discussions_storage["upvotes"].remove(upvote_key)
        reply["upvotes"] -= 1
        action = "removed"
    else:
        # Add upvote
        discussions_storage["upvotes"].add(upvote_key)
        reply["upvotes"] += 1
        action = "added"

    return {"message": f"Upvote {action}", "upvotes": reply["upvotes"]}

@router.put("/replies/{reply_id}", response_model=DiscussionReplyResponse)
async def update_discussion_reply(
    reply_id: UUID,
    reply_data: DiscussionReplyUpdate,
    current_user: LMSUser = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Update a discussion reply"""

    reply = discussions_storage["replies"].get(reply_id)
    if not reply:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Reply not found"
        )

    # Check permissions
    thread = discussions_storage["threads"].get(reply["thread_id"])
    course = db.query(Course).filter(Course.id == thread["course_id"]).first()
    is_instructor = course and course.instructor_id == current_user.id
    is_author = reply["author_id"] == current_user.id

    if not is_author and not is_instructor:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You don't have permission to update this reply"
        )

    # Update fields
    update_data = reply_data.dict(exclude_unset=True)

    # Only instructor can mark as answer
    if not is_instructor:
        update_data.pop("is_answer", None)

    for field, value in update_data.items():
        reply[field] = value

    reply["updated_at"] = datetime.now(timezone.utc)

    # Update thread resolved status if marking as answer
    if "is_answer" in update_data and update_data["is_answer"] and is_instructor:
        thread["is_resolved"] = True

    # Get author info
    author = db.query(LMSUser).filter(LMSUser.id == reply["author_id"]).first()

    return DiscussionReplyResponse(
        **reply,
        author={
            "id": str(author.id),
            "first_name": author.first_name,
            "last_name": author.last_name,
            "email": author.email
        } if author else {"id": str(reply["author_id"]), "first_name": "Unknown", "last_name": "", "email": ""},
        replies=[]
    )

@router.delete("/replies/{reply_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_discussion_reply(
    reply_id: UUID,
    current_user: LMSUser = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Delete a discussion reply"""

    reply = discussions_storage["replies"].get(reply_id)
    if not reply:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Reply not found"
        )

    # Check permissions
    thread = discussions_storage["threads"].get(reply["thread_id"])
    course = db.query(Course).filter(Course.id == thread["course_id"]).first()
    is_instructor = course and course.instructor_id == current_user.id
    is_author = reply["author_id"] == current_user.id

    if not is_author and not is_instructor:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You don't have permission to delete this reply"
        )

    # Delete reply and its children
    def delete_reply_tree(rid):
        # Find and delete child replies
        child_replies = [r_id for r_id, r in discussions_storage["replies"].items() if r.get("parent_reply_id") == rid]
        for child_id in child_replies:
            delete_reply_tree(child_id)

        # Delete the reply itself
        if rid in discussions_storage["replies"]:
            del discussions_storage["replies"][rid]
            thread["reply_count"] -= 1

    delete_reply_tree(reply_id)